The ECTUN protocol is designed to provide an encrypted, authenticated TCP
connection between two hosts, one of which (the server) has a known public key.
ECTUN optionally supports having the client authenticate to the server with a
public key as well, which is assumed to be known to the server.

ECTUN is distinguished from the SSH protocol by lacking support for
multiplexing, tunnelling, or other complex transports. ECTUN is distinguished
from the SSL protocol by lacking X509 certificates (in general), and therefore
CRLs, CAs, and so on.

ECTUN relies on the following cryptographic primitives:

Ss: symmetric key size.
Sa: asymmetric key size.
Sh: Hash size.
Sm: HMAC size.
R(n): n random bits.
H(b): the cryptographic hash of a byte string b.
HMAC(k, b): the HMAC of a byte string b with a key k, appended to b.
Es0(k, b): the byte string b, symmetrically encrypted with a key k.
Ds0(k, b): the byte string b, symmetrically decrypted with a key k.
Ea(k, b): the byte string b, asymetrically encrypted to public key k.
Da(k, b): the byte string b, asymetrically decrypted with private key k.

In revision 0 of this specification:
Ss = 256
Sa = 2048
Sh = 256
Sm = 256
H = SHA256
HMAC = HMAC-SHA256
Es, Ds = AES-256-CTR
Ea, Da = RSAES-OAEP+SHA256, e = 65537, |n| >= 2048

Furthermore, let:
x || y: "append y to x"
x ^ y: "x xor y"

The ECTUN protocol is based on a bidirectional flow of datagrams, each of which
is encrypted and authenticated. For protocol description purposes, let:

S be a server
C be a client
Ksu be S's public key, which is known in advance to C. Used for encryption.
Ksp be S's private key. Used for decryption.
Kcu be C's public key, which may be known in advance to S. Used for encryption.
Kcp be C's private key. Used for decryption.

Note that the counter used in Es and Ds is 128 bits long and initialized to
zero (for client-to-server messages) and 2 ** 127 (for server-to-client
messages). Since a session key is randomly generated each time and a 128-bit counter
is extremely unlikely to wrap during a session, reuse of a (session key,
counter) pair should be expected never to happen.

1. Client hello: The client generates two nonces Nce and Ncm, and a symmetric
key Kt.  It then produces a package composed of the two nonces and its public
key concatenated together, encrypts the package with K, encrypts K to the
server's public key, and sends the results:
	C: Nce = R(Ss)
	C: Ncm = R(Ss)
	C: Kt = R(Ss)
	C -> S: Ea(Ksu, Kt) || Es(Kt, Nce || Ncm || Kcu)
The server receives this message and decrypts it, learning Nce, Ncm, and Kcu. It
optionally verifies that Kcu is on its whitelist of allowed public keys.
	S: Da(Ksu, Kt) -> Kt
	S: Ds(Kt, Es(Kt, Nce || Ncm || Kcu)) -> Nce, Ncm, Kcu
The server and client now share Nce and Ncm.
2. Server hello: The server generates two nonces Nse and Nsm, then combines them
with Nce and Ncm to generate Ke and Km. The server responds with Nse and Nsm,
encrypted to Kcu and HMACed with Km:
	S: Nse = R(Ss)
	S: Nsm = R(Ss)
	S: Ke = Nce ^ Nse
	S: Km = Ncm ^ Nsm
	S -> C: Ea(Kcu, HMAC(Km, Nse || Nsm || H(Nce)))
The client receives this message:
	C: Da(Kcp, Ea(Kcu, HMAC(Km, Nse || Nsm))) -> HMAC(Km, Nse || Nsm)
	C: Ke = Nce ^ Nse
	C: Km = Ncm ^ Nsm
	C: Verify HMAC(Km, Nse || Nsm) matches message.
3. Session: To send a message b, send:
	HMAC(Km, Es(Ke, b))

Security:
Assuming the attacker does not have Ksp or Kcp, ECTUN is secure against a
passive attacker as follows: since the attacker does not have Ksp or Kcp, they
cannot decrypt either the client hello or the server hello, and will therefore
have neither Nse nor Nce, and will therefore be unable to decrypt session
messages. Neither Ksp nor Kcp are ever sent over the wire.

ECTUN is secure against an active attacker as follows:
At step 1, the attacker can replace Nce, Ncm, and Kcu with Nae, Nam, and Kau
respectively.

The attacker cannot learn Nce or Ncm, since they do not possess Ksp. Suppose
they replace Nce and Ncm with Nae and Nam, leaving Kcu unchanged, causing the
server to compute Ke' = Nae ^ Nse and Km' = Nam ^ Nsm; then the server's
response is:
	Ea(Kau, HMAC(Km', Nse || Nsm))
The attacker can decrypt this message and learn Km'; however, Km' != Km, so they
(not knowing Ncm to produce Km) are unable to produce the HMAC(Km, Nse || Nsm)
that would cause C to accept this packet. C will refuse to proceed with the
protocol; the attacker can talk to S, but since they have substituted Kau in for
Kcu in the client hello message, they are talking under their own identity, not
C's.

At step 1, the attacker can replace just Nce and Ncm with Nae and Nam
respetively, leaving Kcu intact; then the server compues Km' as above and
replies with Ea(Kcu, HMAC(Km', Nse || Nsm || H(Nae)), and again C refuses to
continue as Km != Km' and H(Nae) != H(Nce).

There is also a slightly more insidious attack: since the client hello message
is not authenticated in any way, and the symmetric cipher used is malleable, the
attacker can flip arbitrary bits in any of Nce, Ncm, or Kcu to replace them with
Nxe, Nxm, or Kxu, but they do not know the values of any of these. Replacing Ncm
with Nxm will cause the HMAC in the server hello to fail because Km != Nxm ^
Nsm; replacing Nce with Nxe will cause H(Nxe) to mismatch the expected H(Nce) in
the server hello message. Replacing Kcu with Kxu will produce a server hello
that no party can decrypt.

The security of the protocol against active attackers hinges on the fact that
under no circumstances can the attacker obtain Nce or Ncm.

Wire protocol:
ECTUN messages always begin with a message type (a four-byte field), followed by
a payload. Packet types are listed below. All integers are represented on the
wire in network byte order.

Client Hello: Packet type 0x45431000.
	4 bytes of RSA message length
	Encrypted to Ksu:
		Ss bits of Kt
	Encrypted with Kt:
		Ss bits of Nce
		Ss bits of Ncm
		>=Sa bits of Kcu

Server Hello: Packet type 0x45432000.
	Encrypted to Kcu:
		Ss bits of Nse
		Ss bits of Nsm
		Sh bits of H(Nce)
		Sm bits of HMAC

Session: Packet type 0x45433000.
	Counter value for this packet
	Encrypted with Ke:
		b bits of message
	Sm bits of HMAC
